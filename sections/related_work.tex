%!TEX root = ../copatterns-thesis.tex
\chapter{Related Work}


\section{Size-change Termination}
Since Idris already has a working totality checker using size-change termination\,\citep{BradyIdrisImpl13}, it would be interesting if the size-change principle could be used for determining the productivity of corecursive functions as well. The size-change principle for termination was first proposed for a strict first-order functional language (without loop constructs) by Lee, Jones, and Ben-Amram\,\citep{LeeJones01SizeChange}. The principle essentially states that if infinitely many recursive calls to a function would lead to infinite decrease in some parameter value, then the function must be terminating, since any value of an inductive type must have finite size. This last condition is of particular importance, as the size-change principle cannot in general recognize functions as being terminating if they have parameters that do not exhibit a well-founded order. Lee, Jones, and Ben-Amram present two realizations of the principle, one using automata and one using a call graph. In the graph formulation, termination is determined by identifying any recursive calls (both direct and indirect) through cycles in the call graph, and then constructing a ``size-change graph'' for each of these. The size-change graphs are then used to find out whether infinite descent in some parameter value is present. One of the limitations of this approach is that parameter values must decrease monotonically: Values cannot at any point become structurally larger, even though the total change in size in a call chain would ultimately lead a to a decreasing value. Two examples of size-change terminating functions are shown in Figure~\ref{fig:sizechange_plus_map}. In both examples, the recursive call happens on structurally smaller input.

\begin{figure}
\begin{lstlisting}[mathescape]
plus : Nat $\to$ Nat $\to$ Nat
plus Z      m = m
plus (S n') m = plus n' m

map : (a $\to$ b) $\to$ Vect n a $\to$ Vect n b
map f []        = []
map f (x :: xs) = f x :: map f xs
\end{lstlisting}
\caption{Two size-change terminating functions.}
\label{fig:sizechange_plus_map}
\end{figure}

Since its first-order formulation, the principle has been proven to be applicable to more expressive cases. Jones and Bohr\,\citep{Jones04Untyped} showed that size-change termination can be applied to the untyped lambda calculus using abstract interpretation\,\citep{Jones:1995}. A set of safe size-change graphs for a program is generated by defining evaluation rules without an environment component, thus overapproximating the number of possible values for any given variable. Given these rules, a corresponding overapproximated set of safe size-change graphs is generated for further termination analysis. Note that due to the undecidability of the halting problem, it is impossible in general to compute the exact set of safe size-change graphs for a given function call.

Following the work on the untyped lambda calculus, Sereni and Jones generalized the size-change principle to handle a higher-order functional language with user-defined data types and general recursion\,\citep{Sereni05terminationanalysis,Sereni06Phd}. Here, a termination criterion is presented which works for arbitrary control-flow graphs, and in turn is able to give an approximation of termination for both strict and lazy functional programs. A key point in this work is how different approaches to control-flow and call graph construction may influence the preciseness of the termination analysis.

All of the previously mentioned implementations of the size-change principle can only approximate termination for programs involving data which exhibits some well-founded order. Nevertheless, Avery\,\citep{Avery06} presented a formulation in which it is possible to detect size-change termination for non-well-founded data types --- in particular, this formulation is shown to work for a language with an integer type. Instead of identifying infinite descent using a well-founded partial order on parameter, as proposed by Lee at al., Avery's analysis is based on a decrease in invariants which are found to hold for each program point. The idea is that if the value of some invariant (which can involve arbitrarily many values) can be shown to decrease on every passage of a program point, then the program terminates. A simple example of a size-change terminating program in Avery's implementation is given in Figure~\ref{fig:avery_example}. The invariant for the inner loop is \texttt{n - j + i}, while the one for the outer loop is \texttt{n - i}. These cannot decrease indefinitely, and therefore the program is size-change terminating.

\begin{figure}
\begin{lstlisting}
for (i = 0; i <= n; i++) {
  for (j = 0; j-i <= n; j++);
}
return;
\end{lstlisting}
\caption{An example program involving integers written in a subset of C, which is size-change terminating in Avery's formulation.}
\label{fig:avery_example}
\end{figure}

While size-change termination for non-well-founded data could be a step towards using a size-change approach for an approximation of productivity, it is unclear which invariants one would have to infer for corecursive programs. A first attempt might emerge from the observation that any productive corecursive program cannot consume any more data than it produces. Based solely on syntax, such an analysis would quickly approach the idea behind syntactic guardedness checkers, which will be discussed in Section~\ref{sec:synt-guard}.

The termination criterion most similar to the size-change principle predates the original article by Lee, Jones, and Ben-Amram\,\citep{LeeJones01SizeChange}. This criterion was developed by Abel for the \texttt{foetus} termination checker\,\citep{Abel98foetus}, and forms the basis of the totality checker implemented in Agda\,\citep{Norell:thesis}. Analogous to the size-change principle, Abel identifies recursive calls in a call graph and performs a termination analysis by tracking changes in parameter sizes. This initial presentation of \texttt{foetus} makes no mention of productivity for corecursive programs, although such an extension has since been presented by Altenkirch and Danielsson\,\citep{AltenkirchNAD10} (for further discussion, see Section~\ref{sec:synt-guard}).

\section{Syntactic Guardedness}
\label{sec:synt-guard}
% Telford and Turner nÃ¦vnes mere
% Hyvernat flyttes herned

Due to the duality between inductive and coinductive types, it may be compelling to imagine a productivity analysis which, dual to the size-change principle, works by identifying structurally larger values. Such a dual notion of ``size-change productivity'' is exactly the idea behind the syntactic guardedness checkers found in Idris, Agda, and Coq\,\citep{Coq:manual}. 

\section{Guarded Recursion}
%neelk
%Atkey and McBride
%Flere papers fra Aarhus

\section{Sized Types}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../copatterns-thesis"
%%% End:
