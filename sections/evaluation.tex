\chapter{Evaluation}
\label{cha:evaluation}
\todo{Link back to motivation}
\section{Guarded Recursion}
In Chapter~\ref{cha:infer-guard-recurs} we discussed an inference and checking
system for guarded recursion. In the following we will present the results of
implementing such a system in Idris, including what can now be proven total, but
also what consequences the scoping we have done has had.

Our goal was to add a less restrictive productivity checker to Idris with
guarded recursion. Let us therefore start by looking at what we can now prove
total in Idris, which we could not before. In
Figure~\ref{fig:productivity_table} a list of function (names) along side their
found productivity with different checking methods can be found. See
Appendix~\ref{sec:guarded-recursion-1} for the implementation of the functions.

\begin{figure}[h]
\begin{center}
  \begin{tabular}{| l | c | c |} \hline
    Function & Syntactic Guardedness & Guarded Recursion \\ \hline
    zeros & Productive & Productive \\ \hline
    repeat & Productive & Productive \\ \hline
    map & Productive & Productive \\ \hline
    zipWith & Productive & Productive \\ \hline
    toggle & Productive & Productive \\ \hline
    interleave & Productive & Productive \\ \hline
    nats & Not Productive & Productive \\ \hline
    fib & Not Productive & Productive \\ \hline
    paperfold & Not Productive & Productive \\ \hline
    paperfold' & Not Productive & Not Productive \\ \hline
%    & & \\ \hline
  \end{tabular}
\end{center}
  \caption{Functions and their productivity according to Idris current totality
    checker and according to our guarded recursion checker. The actual programs
    can be found in Appendix~\ref{app:example-programs}. Note that it is
    according to our system implementing guarded recursion, not guarded
    recursion in general.}
  \label{fig:productivity_table}
\end{figure}

\subsection{Examples of inference}
As we saw we have successfully checked functions for productivity by inferring
guarded recursion. Let us therefore inspect the terms we have inferred, such
that we can convince ourself that we have actually inferred guarded
recursion. Consider the simple example \texttt{zeros}:

\begin{lstlisting}[mathescape]
zeros : Stream Nat
zeros = Z :: zeros
\end{lstlisting}

The first thing we do is to find the guarded
recursive type for the function. Here, \texttt{Stream Nat} becomes $\forall
\kappa$\texttt{.Stream}$^\kappa$ \texttt{Nat}. Once this is done we must find a
transformation from \texttt{Z :: zeros} of type \texttt{Stream Nat} to a term of
type $\forall \kappa$\texttt{.Stream}$^\kappa$ \texttt{Nat}:
\[
IE \vdash Z :: zeros : Stream\,Nat\Longrightarrow \,e : \forall \kappa.Stream^\kappa \,Nat
\]
\[
IE = zeros;\, \causal ;\,\phi, (::,\ _g::), (zeros,\, _gzeros);\, \open;\,
\Gamma,Z : Nat,\ zeros : Stream Nat,\,_gzeros : \forallk{Stream} Nat
\]

We now need to infer a term for $e$. Using the rules from \todo{make ref}, we
end up with the following guarded recursive definition:

\begin{lstlisting}[mathescape]
$_g$zeros : $\forall \kappa$.Stream$^\kappa$ Nat
$_g$zeros = Z $_g$:: (Next$^\kappa$ apply $_g$zeros)
\end{lstlisting}

Details on this inference is to be found in
Appendix~\ref{cha:example-inferences}. A more interesting example is
\texttt{nats}: 

\begin{lstlisting}[mathescape]
nats : Stream Nat
nats = Z :: (map S nats)
\end{lstlisting}

We will not go into a lot of details about this inference here as it is a fairly
complex and long procedure, but what is interesting is that we have to infer a
later composition because of the availability of the recursive reference. We end
up having to infer:

\[
IE \vdash map\,S\,nats : Stream\,Nat\Longrightarrow \,e : \later^\kappa_1 Stream^\kappa \,Nat
\]
\[
IE = nats;\, \curvearrowleft ;\,\phi, (::, _g::), (nats, _gnats), (map, _gmap);\, \sqcup;\, \Gamma
\]

\begin{lstlisting}[mathescape]
$_g$nats : $\forall \kappa$.Stream$^\kappa$ Nat
$_g$nats = Z $_g$:: (Next$^\kappa$ ((apply $_g$map) S) $\tensor ^\kappa _1$ (Next$^\kappa$ apply $_g$nats))
\end{lstlisting}

\subsection{Singleton Clock}
\label{sec:singleton-clock}
\todo{rewrite}
\subsection{Modality}
Another simplification we introduced was modality where we said that a function was
either causal or noncausal. These two are, however, not the only options. Consider
for example the function \texttt{semiinterleave} in
Figure~\ref{fig:semiinterleave}. This function is neither causal, as the
quantification does not span the entire type, not noncausal, as there is not a
quantification on each argument.

\begin{figure}[h]
\begin{lstlisting}[mathescape]
semiinterleave : $\forall \kappa$.Stream$^\kappa$ a $\to$ $\forall \kappa$(Stream$^\kappa$ a $\to$ Stream$^\kappa$ a)
semiinterleave s = $\Lambda \kappa.$ semiinterleave'(s)

semiinterleave' : $\forall \kappa$.Stream$^\kappa$ a $\to$ Stream$^\kappa$ a $\to$ Stream$^\kappa$ a
semiinterleave' = pfix(f)

f : ($\forall \kappa$.Stream$^\kappa$ a $\to$ $\later$$^{\kappa}$(Stream$^\kappa$ a $\to$ Stream$^\kappa$ a)) $\to$ 
       $\forall \kappa$.Stream$^\kappa$ a $\to$ Stream$^\kappa$ a $\to$ Stream$^{\kappa}$ a
f g xs s = StreamCons (head xs)
    (Next (StreamCons (head s) 
                      ((g (tail (tail xs))) $\tensor^\kappa$(tail s))))
\end{lstlisting}
\caption{A function interleave a stream with the even indices of another
  stream.}
\label{fig:semiinterleave}
\end{figure}

The programmer is not able to specify this type in our system, and we can
therefore not correctly check its productivity. We do, however, see that there
are many useful functions which fall into one of these two modality catagories,
and that we have to resort to the more contrived examples, such as
\texttt{semiinterleave}, to find functions we cannot define.

\subsection{User written Guarded Recursion}
While the main purpose of our system is to let users utilize guarded recursion,
without actually writing it, to write productive functions, we aimed to design
our system such that it would be possible to write and check guarded
recursion without any inference. To achieve this we decoupled the inference and
the checking algorithm in such a way that programs already defined as guarded
recursion could be send directly to the checker. 

Sadly, there are other considerations to take, and, currently, a user can not
yet write his own guarded recursive definitions. Taking a side the Idris
technical issues, mainly directing the user written guarded recursion to the
checker, a problem is that in Section \todo{check ref}we eliminated the fixed
point operator.

The checking algorithm expects this kind of guarded recursion without a fixed
point, meaning that this is what the user will have to write. This requires the
user to not only have knowledge about guarded recursion, but also of how our
implementation of it works.

% Brugeren kan ikke, endnu skrive sin egen GR
% Singleton clock og modalitet er hovedsageligt for at gøre inference
% nemmere. Måske checkeren kunne være ligeglad? Det kunne gør at man kunne
% skrive vildere GR programmer selv.
%#############
% GR evaluation 
% Hvor godt virker vores løsning til guarded recursion?
% Hvad virker? Hvad virker ikke?
%% Instans funktioner
%% Relaterede funktioner
% Hvad burde virke?
%#############

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../copatterns-thesis"
%%% End:
