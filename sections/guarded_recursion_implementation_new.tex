\chapter{Inference of Guarded Recursion}
\label{cha:infer-guard-recurs}
In Section~\ref{sec:less-restr-prod}, we provided the motivation behind
extending Idris with a less restrictive productivity checker using guarded
recursion. As we saw in Section~\ref{sec:guarded-recursion}, defining guarded
recursive programs can be quite tedious and requires the user to thoroughly
understand guarded recursion in order to write provably productive programs. In
this chapter, we propose a system where the productivity of programs can be
verified using guarded recursion with only a minimal amount of user
involvement. The main focus will be on implementation, showing how we have put theory into practice.

\section{Practical Considerations}
Applying a theoretical model for productivity to actual Idris programs means
that we must address several practical issues concerning the Idris compiler.

\subsection{Target Language}
As discussed in Chapter~\ref{cha:idris}, an Idris program has multiple different
representations throughout the compilation process, namely concrete Idris,
\IdrisM{}, TT, IBC, and binary. Therefore, the compilation
stage and program reprensentation chosen for the productivity analysis has great
impact on how a solution unfolds.

Since guarded recursion is a typing discipline, the system needs the ability to
resolve the type for an arbitrary term. This is not possible prior to
elaboration, because type resolution may require evaluation. Seeing as program
structure is important for the analysis, both IBC and the binary representation
would be impractical as target languages. After elaboration, the resulting TT
terms have all type information available, while program structure is still
preserved. Hence, the productivity analysis is performed on elaborated TT terms.

\subsection{Handling Parameters} % -- Subsubsection to forrige section?
\label{sec:handling-parameters}
Recall the typing rule for the later composition operator, $\tensor^\kappa$, in
Figure~\ref{fig:guarded_recursion_rules_clocks}:

\input{figures/guarded_tensor_intro_rule}

While this rule provides us with a mechanism for sequential application of
values available later, it only works for the simply typed case. Notably, it
does not take substitution in the resulting type into account, so the function
argument to $\tensor^\kappa$, $f$, can never be applied to an argument $e$ which
refines the type of $f$, e.g. a type argument. The following function,
\texttt{repeat}, requires an application of a type argument:

\begin{lstlisting}[mathescape]
repeat : $\forall \kappa.$ ((a : Type) $\rightarrow$ a $\rightarrow$ Stream$^{\kappa}$ a)
repeat = $\Lambda\kappa.$ fix$^{\kappa}$($\lambda{}$rec$.\lambda{}$a$.\lambda{}$n$.$ 
             StreamCons a n ((rec $\tensor ^{\kappa}$ (Next$^{\kappa}$ a)) $\tensor ^{\kappa}$ (Next$^{\kappa}$ n)))
\end{lstlisting}

By fixed-point elimination, the recursive reference is under an application
of \texttt{Next$^\kappa$}, making it available later. Therefore, it must be
applied to its type argument by later composition, but such an application
is not well-typed, as shown in Figure~\ref{fig:repeat_failed_typing}. In
particular, the type argument is not bound as the type variable \texttt{a},
since this connection is not expressed in the typing rule.

\begin{figure}[h]
\centering
\[
\frac { \begin{matrix} \inference { \frac { ? }{ \Gamma '\, \vdash \, (Next^{\kappa}\,repeat[\kappa])\, :\, \later
        ^{\kappa}(Type\, \rightarrow \, a\, \rightarrow \, Stream^{\kappa}\, a) } \, 
      \frac {
        \frac {  }{ \Gamma '\, \vdash \, a\, :\, Type } 
      }
      { \Gamma '\, \vdash \,
        Next^{\kappa}\, a\, :\, \later ^{\kappa}\, Type }
    }{ \, \Gamma '\, \vdash \, (Next^{\kappa}\,repeat[\kappa])\,
      \tensor ^{\kappa} \, (Next^{\kappa}\, a)\, :\, \later ^{\kappa}(a\, \rightarrow \, Stream^{\kappa}\,
      a)\ }  & \inference { \inference {  }{ \Gamma '\, \vdash \, n\, :\, a }  }{
      \Gamma '\, \vdash \, Next^{\kappa}\, n\, :\, \later ^{\kappa} \, a }  \end{matrix} }{
  \Gamma '\, \vdash \, ((Next^{\kappa}\,repeat[\kappa])\, \tensor ^{\kappa} \, (Next^{\kappa}\, a))\, \tensor ^{\kappa} \,
  (Next^{\kappa}\, n))\, :\, \later ^{\kappa} Stream^{\kappa}\, a }
\]
\[
\Gamma '\, =\, \Gamma ,\, (Next^{\kappa}\,repeat[\kappa])\, :\, \later ^{\kappa}((a\, :\, Type)\, \rightarrow \,
a\, \rightarrow \, Stream^{\kappa}\, a),\, a\, :\, Type,\, n\, :\, a
\]
  \caption{A failed attempt at typing the tail argument to the
    \texttt{StreamCons} constructor in the definition of \texttt{repeat}.}
  \label{fig:repeat_failed_typing}
\end{figure}

One way of solving this problem would be to change the typing rule for later
composition, such that it takes substitution in types into account, as shown in
Figure~\ref{fig:tensor_with_subst}. However, this formulation of the rule has
yet to be proven sound.

\begin{figure}[h]
\[
\inference { \Gamma \, \vdash \, t\, :\, \later^{\kappa} ((a\, :\, A)\,
  \rightarrow \, B)\quad \Gamma \, \vdash \, u\, :\, \later^{\kappa} A }{
  \Gamma \, \vdash \, t\, \tensor ^{\kappa} \, u\, :\, \later^{\kappa} B[{ u
  }/{ a }] } 
\]
  \caption{Rule for later composition with substitution in types.}
  \label{fig:tensor_with_subst}
\end{figure}

Instead, we can change which arguments that appear under the fixed-point. Any
parameter which would have to be substituted in the type is therefore lifted out
of the fixed-point operator, 
thus changing the type of the recursive reference. This gives us
the definition of \texttt{repeat} in
Figure~\ref{fig:repeat_guarded_example_new}, where the type of the recursive
reference is \texttt{$\later ^{\kappa}$(a~$\rightarrow$~Stream$^{\kappa}$
  a)}. This allows us to type part of \texttt{repeat} as exemplified in
Figure~\ref{fig:repeat_typing_new}, because the type parameter is now fixed
outside of the fixed-point operator.

\begin{figure}[h]
  \begin{lstlisting}[mathescape]
repeat : (a : Type) $\to$ $\forall \kappa.$ (a $\to$ Stream$^{\kappa}$ a)
repeat a = $\Lambda \kappa$ fix$^{\kappa}$($\lambda{}$rec$.\lambda{}$n$.$ 
             StreamCons a n (rec $\tensor ^{\kappa}$ (Next$^{\kappa}$$^{\kappa}$ n)))
\end{lstlisting}
  \caption{A definition of \texttt{repeat} where the type parameter is fixed
    outside of the fixed-point operator.}
  \label{fig:repeat_guarded_example_new}
\end{figure}

\begin{figure}[h]
\[
\frac { \frac {  }{ \Gamma '\, \vdash \, rec\, :\, \later ^{\kappa}(a\, \rightarrow
    \, Stream^{\kappa}\, a) } \, \frac { \Gamma '\, \vdash \, n\, :\, a }{ \Gamma '\,
    \vdash \, Next^{\kappa}\, n\, :\, \later ^{\kappa}\, a }  }{ \, \Gamma '\, \vdash \, rec\,
  \tensor ^{\kappa} \, (Next^{\kappa}\, n)\, :\, \later ^{\kappa}Stream^{\kappa}\, a }
\]
\[
 \Gamma '\, =\, \Gamma ,\, rec\, :\, \later ^{\kappa}(a\, \rightarrow \, Stream^{\kappa}\,
 a),\, a\, :\, Type,\, n\, :\, a
\]

  \caption{Part of typing repeat with fixed type parameter.}
  \label{fig:repeat_typing_new}
\end{figure}

The problem described here applies to all function parameters which refine the
output type or the type of other parameters. As such, any such parameter must be
lifted out of the fixed-point in this manner.


\subsection{The \texttt{fix$^\kappa$} Rule}
\label{sec:fixkappa-rule}
In the theoretical model of guarded recursion, all programs must be encoded
inside a special fixed-point operator, as shown in
Section~\ref{sec:guarded-recursion}. Ideally, we could simply port this idea to
Idris, encoding TT programs inside a TT definition of the fixed-point
operator. While this would work fine for single-clause definitions, it becomes
problematic when we consider definitions with multiple clauses, such as the
following: 

\begin{lstlisting}[mathescape]
cycle : Nat $\to$ Nat $\to$ Stream Nat
cycle Z     m = Z :: (cycle m m)
cycle (S n) m = (S n) :: (cycle n m)
\end{lstlisting}

When transforming \texttt{cycle} to guarded recursive form, both clauses must be part
of the same fixed-point definition. A seemingly obvious solution is to convert
the left-hand side pattern matching structure in \texttt{cycle} into right-hand
side \texttt{case}-expressions. For two reasons, this is not possible: (1) the
definition of \texttt{cycle} is elaborated into two TT clauses, and (2) Idris
\texttt{case}-expressions only support non-dependent pattern matching. Hence,
the problem persists after elaboration.

Instead, we could attempt to define \texttt{cycle} as two functions: A
single-clause definition with the fixed-point operator, and an auxiliary
function where pattern matching is performed, as seen in
Figure~\ref{fig:cycle_guarded}. With this solution, all the clauses of
\texttt{cycle} are part of the same fixed-point, where the guarded recursive reference,
\texttt{rec}, is given to \texttt{cycle} as an argument.

\begin{figure}[h]
\begin{lstlisting}[mathescape]
cycle$'$ : $\laterkappa\,$(Nat $\to$ Nat $\to$ Stream$^{\kappa}\,$Nat) $\to$ Nat $\to$ Nat $\to$ Stream$^{\kappa}$ Nat
cycle$'$ rec  Z    m = StreamCons Z  ((rec $\tensor ^{\kappa}$ (Next$^{\kappa}$ m)) $\tensor ^{\kappa}$ (Next$^{\kappa}$ m))
cycle$'$ rec (S n) m = StreamCons (S n) ((rec $\tensor ^{\kappa}$ (Next$^{\kappa}$ n)) $\tensor ^{\kappa}$ (Next$^{\kappa}$ m))

cycle : $\forall \kappa.\,$(Nat $\to$ Nat $\to$ Stream$^{\kappa}\,$Nat)
cycle = $\Lambda \kappa.\,$fix$^{\kappa}$($\lambda$rec.$\lambda$n.$\lambda$m. cycle rec n m)
\end{lstlisting}
  \caption{A guarded recursive definition of \texttt{cycle}, where the pattern
    matching is handled by an auxiliary function \texttt{cycle'}. The
    \texttt{Stream$^\kappa$ type is defined in Figure~\ref{fig:guarded_recursion_stream}.} }
  \label{fig:cycle_guarded}
\end{figure}

Up to polymorphic types, this approach works as expected, but it becomes
insufficient once we consider dependent types. When the recursive reference is
placed under the fixed-point operator, its type is fixed as well. For example, in the function \texttt{prepend} from
Figure~\ref{fig:guarded_prepend}, the \texttt{n} in the type of \texttt{rec} is
fixed. But \texttt{n} is refined to \texttt{Z} in first clause and \texttt{S n}
in the the second clause, respectively, so \texttt{rec} can never be applied to
\texttt{xs} in a well-typed manner, since the type of xs is \texttt{Vect n a}.

\begin{figure}[h]
\begin{lstlisting}[mathescape]
prepend$'$ : ($\laterkappa\,$(Vect n a $\to$ Stream$^{\kappa}\,$a $\to$ Stream$^{\kappa}\,$a)) $\to$ 
           Vect n a $\to$ Stream$^{\kappa}\,$a $\to$ Stream$^{\kappa}\,$a
prepend$'$ rec []        s = s 
prepend$'$ rec (x :: xs) s = StreamCons x ((rec $\tensor$ (Next xs)) $\tensor$ (Next s))

prepend : $\forall\kappa.$(Vect n a $\to$ Stream$^\kappa$ a $\to$ Stream$^\kappa$ a)
prepend = $\Lambda\kappa.\,$fix$^\kappa$($\lambda$rec.$\lambda$xs.$\lambda$s. prepend rec xs s)
\end{lstlisting}
  \caption{A function prepending a vector on a stream. This definition is not well-typed.}
  \label{fig:guarded_prepend}
\end{figure}

To circumvent all of these issues, we eliminate the fixed-point operator altogether according
to the elimination rules in Figure~\ref{fig:fix_elim_rules}. By eliminating the
fixed-point, the type of the recursive reference is no longer fixed. The
elimination of the fixed-point is well-typed, since \texttt{Next$^{\kappa}$ f}
and the recursive reference, here denoted \texttt{rec}, always have the same
type according to the guarded recursive typing rules in Figure~\ref{fig:guarded_recursion_rules_clocks}.

\begin{figure}[h]
  \[
\frac { \Delta ,\, \kappa ; \, \Gamma \, \vdash \, f\, =\, { fix }^{ \kappa  }(\lambda
  rec.\, e)\, :\, A }{ \Delta ,\, \kappa \, ; \Gamma \vdash \, f\, =\, e[{ (Next^{ \kappa
    }\,f) }/{ rec }]\, :\, A } fix_{E_1}
\]

\[
\frac { \Delta \, ; \Gamma \vdash \, f\, =\, \Lambda \kappa .{ fix }^{ \kappa  }(\lambda
  rec.\, e)\, :\, \forall \kappa .A }{ \Delta \, ; \Gamma \vdash \, f\, =\, \Lambda
  \kappa .e[{ (Next^{ \kappa  }\, f[\kappa ]) }/{ rec }]\, :\, \forall \kappa .A
} fix_{E_2}
\]
  \caption{Rules for fix elimination}
  \label{fig:fix_elim_rules}
\end{figure}
\todo{Is there a better way express the fix elimination rules?}

After elimination of the fixed-point operator, the guarded recursive version of
\texttt{prepend} can be defined as follows:

\begin{lstlisting}[mathescape]
prepend : $\forall\kappa.$(Vect n a $\to$ Stream$^\kappa$ a $\to$ Stream$^\kappa$ a)
prepend []        s = $\Lambda\kappa.\,$s
prepend (x :: xs) s = $\Lambda\kappa.\,$StreamCons x 
                          (((Next$^\kappa$ prepend) $\tensor$ (Next$^\kappa$ xs)) $\tensor$ (Next$^\kappa$ s))
\end{lstlisting}

An elaboration upon this solution will be provided in Section~\ref{sec:impl-guard-recurs}.

\section{Scope}
To reduce the complexity of the implementation, we have narrowed the scope for
two central areas, namely the amount of clock variables supported and the types
of inferred functions.

\subsection{Singleton Clock}
% Argumenter:
%% Hvornår bruger man hvilket ur?
%% GR-regler for checkeren her
%%
% f = /\k. fix(\rec. e)
% f = /\k. e[(Next(f[k])/rec]

% e :
% e1 = rhs[Next(f[k])/rec]
% e2 = 
The theoretical model for guarded recursion with clock variables, due to Atkey
and McBride\,\citep{Atkey:2013}, imposes no limitations on the amount
simultaneous of clock variables. This means that their system is very
expressive, but can lead to quite complicated definitions where the user must
explicitly specify which clock variable that is applicable in a given situation to ensure
productivity. Automating the process of choosing the right clock variable for
any given scenario is not feasible in general, since for $n$ scenarios with $c$
clocks in scope, the number of possible combinations is $O(c^n)$.

To avoid the problem of finding the correct combination clock variable, we
simplify our system such that at most one clock is in scope at any given
time. The implication is that our productivity analysis will never return a
positive answer for programs whose guarded recursive equivalent requires more
than one clock. However, as noted by Clouston et
al.\,\citep{BirkedalL:guarded-lambda-conf}, all examples in the current literature
on guarded recursion require only one clock. This claim will be supported by our
evaluation in Chapter~\ref{cha:evaluation}, where we show a that significant number of
realistic programs have guarded recursive versions which require only one clock.

Incorporating this simplification means that we must adjust the typing rules for
guarded recursion accordingly. The adjusted rules are shown in
Figure~\ref{fig:gr_rules_sin_clock}. Instead of having a specific clock
environment, the singleton clock is either open ($\sqcup$) or closed ($\sqcap$). 

\begin{figure}[h]
  
  \caption{Guarded Recursion rules with singleton clock.}
  \label{fig:gr_rules_sin_clock}
\end{figure}

While deriving this set of adjusted rules from the original rules has not followed a specific
methodology, a general trend is:

\begin{itemize}
\item If the original rule required a specific clock in the environment, the
  adjusted rule requires an open clock.
\item Side conditions concerned with specific clocks not being free in the
  environment are adjusted so that no free clocks are allowed in the
  environment at all.
\end{itemize}

Note that the $\kappa$, indicating which clock that applies for a given term,
has been removed from most of the types and terms. Seeing as the rules can only
express properties about the singleton clock, it is unnecessary to specify the
current clock explicitly. For example, all $\later$ types now always operate on the
same clock. However, $\kappa$ remains in some cases, such as $\forall \kappa$ and
$\Lambda \kappa$. These still only mention the singleton clock, but the
$\kappa$ has been kept in order to disambiguate $\forall \kappa$ from standard universal quantification and
$\Lambda \kappa$ from standard lambda abstractions.

\subsection{Causal and Non-causal Functions}
\label{sec:causal-non-causal}
% Problem: The inferred type might not be the intended type, since more than one
% may be correct.
When defining a guarded recursive function, one has to consider the clock
quantification in its type. For example, in the definition of \texttt{cycle}
from Figure~\ref{fig:cycle_guarded}, the clock quantification is on
the entire type, whereas in the definition of \texttt{evens} from
Figure~\ref{fig:guarded_recursion_evens}, the clock quantification is on each
individual parameter type. As the number of arguments to a function is
increased, the number of different ways we could quantify the function increases
as well.

Since we cannot in general infer the correct combination of clock
quantifications for an arbitrary type, we simplify the problem by introducing
the idea of \emph{modality}. Modality is a property of a function definition,
specifying that it is in one of two disjoint modes: \emph{causal} or
\emph{non-causal}. If a function is causal, the clock quantification is on the
entire type, since this models Definition~\ref{def:causality}. Informally, the
output of a causal function at time $n$ can only depend on the input at time
$n$. If a function is non-causal, the quantification is on each individual
guarded type, since the output of a non-causal function may depend arbitrarily
on its input. Therefore, the definition of \texttt{evens} in
Figure~\ref{fig:guarded_recursion_evens} is non-causal.

\begin{definition}[\textit{Causality}]
\label{def:causality}
  Given a function $f : A \to B$ and an element $x : A$, where $B$ is a
  coinductive type, $f$ is \emph{causal} if the computation of the first $n$
  unfoldings of $f x$ only depends on the result of the first $n$ unfoldings of $x$.
\end{definition}

While inferring the modality of a function is possible, simply by trying all
possible combinations of clock quantification on its type, some functions may
have both a causal and a non-causal guarded recursive version. Since recursive
references cannot be given as input to non-causal functions, the semantics of
the two versions differ significantly. Instead of attempting to infer the
modality, we introduce the keyword \texttt{causal} as a function option, such
that it must be added to any causal definition. Function definitions which are
not marked as causal are assumed to be non-causal. This means that the
\texttt{cycle} function from Section~\ref{sec:fixkappa-rule} must be given as
follows:
\begin{lstlisting}[mathescape]
causal cycle : Nat $\rightarrow$ Nat $\rightarrow$ Stream Nat
cycle Z     m = Z :: (cycle m m)
cycle (S n) m = (S n) :: (cycle n m)
\end{lstlisting}


\section{Implementation}
\subsection{Preparing Idris}
% Preprocessing, how are guarded data types created?

\paragraph{Guarded Recursion Library}
The first step to adding guarded recursion to Idris is to add the guarded
recursive types and functions. We have added these to the Idris built-in
library, and not as a part of the prelude. This is because the user should be
able to check functions for productivity using our guarded recursion checker
without having to rely on the standard library.  While most of the
implementations are straight forward, and can be found in Appendix\todo{Add ref
  to appendix. And add appendix!}, there are interesting parts to discuss. We
have added the notion of \emph{how much later} something is, through the idea of
\texttt{Availability}, seen in Figure~\ref{fig:availability}. This is, in
conjunction with \texttt{Later} done so that we can many $\later$ applications
as a single \texttt{Later} applications.

\begin{figure}[h]
  \begin{lstlisting}[mathescape]
data Availability = Now | Tomorrow Availability

data Later' : Type -> Type where
  Next : {a : Type} -> a -> Later' a

Later : Availability -> Type -> Type
Later Now a = a
Later (Tomorrow n) a = Later' (Later n a)
\end{lstlisting}
  \caption{Availability.}
  \label{fig:availability}
\end{figure}

\paragraph{Guarded Names}
As we want to infer new types and terms, and not override the existing ones, we
need a system for creating a guarded name from an existing user written
name. While this is fairly trivial, it is an important part of our system. We
will hence forth refer to these as the \emph{guarded names} as oppose to their
original \emph{Idris names}. We will mark these guarded names with a subscript
$g$, such that a name $Name$ becomes $_gName$.

During compilation we keep a map from Idris names to their guarded names. This
means that we can for any Idris name find their guarded name, and vice
versa. This comes in handy when we infer the guarded terms.

\paragraph{Clocked Types}
These are made by inferring a new data declaration for any codata or corecord
declaration. This new data declaration is simply constructed during the
elaboration of the original and then elaborated by itself. This means that for
any user written codata or corecord declaration a guarded version is an
intrinsic part of the program. 

A such guarded version of a declaration is fairly straight forward. Guarded
names are given to the type and to all constructors. Any recursive reference in
the type of the constructor is placed under a $\later$-type, in a similar
fashion to how Idris already handles lazy evaluation. The type constructor
remains unchanged. An example of this inferences for a codata declaration can be
seen in Figure~\ref{fig:guarded_stream_inf}. Note that the inferred declaration
is a data declaration, not codata. This is because we do not need both Idris's
built in laziness (\texttt{Inf}), and the guarded recursion laziness ($\later$)
\todo{Explain why these are not the same}.

\begin{figure}[h]
\begin{lstlisting}[mathescape]
codata Stream : Type -> Type where
  MkStream : a -> Stream a -> Stream a

data $_g$Stream : Type -> Type where
  $_g$MkStream : a -> $\later_g$Stream a -> $_g$Stream a
\end{lstlisting}
  \caption{Inference of the guarded stream declaration.}
  \label{fig:guarded_stream_inf}
\end{figure}

In the corecord case, we take a similar approach. However, instead of
constructors we have to guard projections. Again, any recursive projection is
guarded such that $A \rightarrow A$ becomes $A \rightarrow \later A$, and all
projections are given a guarded name. Figure~\ref{fig:guarded_tree_inf} shows an
example of such an inference.

\begin{figure}[h]
\begin{lstlisting}[mathescape]
corecord Tree a where
  left : Tree a -> Tree a
  value : Tree a -> a
  right : Tree a -> Tree a

record $_g$Tree a where
  $_g$left : $_g$Tree a -> $\later_g$Tree a
  $_g$value : $_g$Tree a -> a
  $_g$right : $_g$Tree a -> $\later_g$Tree a
\end{lstlisting}
  \caption{Inference of the guarded tree declaration.}
  \label{fig:guarded_tree_inf}
\end{figure}

Furthermore, for each projection we also generate what we call a \emph{forall
  projection}, henceforth denoted as $_\forall Name$. We use this for
projections on quantified types. Consider a coinductive type $A$ with a
projection $p$ of type $A \rightarrow A$, and a variable $x$ of type $\forall
\kappa.A$. In order to perform $p$ on $x$ and maintain the quantification in the
type, we must first apply the clock to $x$, apply $_gp$, and then abstract over the
clock again using $\Lambda \kappa$. This gives us:

\[
\Lambda \kappa . _gp (apply\,x) : \forall \kappa . \later A
\]

The type of the above is isomorphic with $\forall \kappa . A$ according to the
isomorphism described by Rasmus M\o gelberg\,\cite{Mogelberg:2014} seen in
Figure~\ref{fig:quantified_later_iso}. As a short for all of this we simply use
$_\forall p$ which has type $\forall A \rightarrow \forall A$, giving us the
same result. As such these \emph{forall projections} do not add anything new,
they are just a simpler way for us to perform projections on terms of quantified
type. The intuition is that because of Figure~\ref{fig:quantified_later_iso} we
can perform projections on quantified types without having to worrying about
their lateness. Because they are quantified over clocks, they are always available.

\begin{figure}[h]
\[
\forall \kappa .A\cong \forall \kappa .\rhd ^\kappa A
\]
  \caption{A type isomorphism describe by M\o gelberg\,\cite{Mogelberg:2014}.}
  \label{fig:quantified_later_iso}
\end{figure}


\subsection{The Implementation of Guarded Recursion}
\label{sec:impl-guard-recurs}
% Meta
%% Samspil mellem inferens og check
%% Hvordan behandles causal vs. non-causal

The inference of guarded recursive versions of productive programs
happens in two steps: (1) the inference system infers a guarded
recursive TT definition from an elaborated TT definition, and (2) the checking
system verifies that the inferred guarded recursive definition is well-formed
according to the typing rules in Figure~\ref{fig:gr_rules_sin_clock}. The two
systems are implemented independently, and the checking system does not rely on
any implementation-specific details of the inference system. Nevertheless, they do agree on
the initial context in which a guarded recursive definition should hold.

As explained in Section~\ref{sec:causal-non-causal}, the system distinguishes between
causal and non-causal definitions. Before making an attempt to infer a guarded
recursive version of a definition, the definition is first preprocessed in order
to ease the inference process. Causal and non-causal definitions are
preprocessed differently, although the steps are the same:

\begin{enumerate}
\item Create auxiliary functions to circumvent the limitations of the
  \texttt{fix$^\kappa$} rule.
\item Lift parameters out of the fixed-point.
\item Eliminate the fixed-point by the fixed-point elimination rules from
  Figure~\ref{fig:fix_elim_rules}.
\item $\beta$-reduction of recursive argument in auxiliary function.
\end{enumerate}

\subsubsection{Preprocessing Causal Functions}
 Consider the causal function \texttt{prepend}, here
given as an ordinary Idris program:
\begin{lstlisting}[mathescape]
  total causal prepend : List a $\to$ Stream a $\to$ Stream a
  prepend []        s = s
  prepend (x :: xs) s = x :: (prepend xs s)
\end{lstlisting}
(1) To infer a guarded recursive version of \texttt{prepend}, we first split the
definition in two, such that pattern matching happens in an auxiliary function,
\texttt{prepend$'$}, which is then called inside the fixed-point of \texttt{prepend}:

\begin{lstlisting}[mathescape]
  prepend$'$ : $\laterkappa$((a$\,$:$\,$Type) $\to$ List a $\to$ Stream$^\kappa$ a $\to$ Stream$^\kappa$ a) $\to$ 
             (a$\,$:$\,$Type) $\to$ List a $\to$ Stream$^\kappa$ a $\to$ Stream$^\kappa$ a
  prepend$'$ rec a []        s = $\uwave{\texttt{s }}$
  prepend$'$ rec a (x :: xs) s = $\uwave{\texttt{x :: (rec a xs s)}}$

  causal prepend : $\forall\kappa.$ (a$\,$:$\,$Type) $\to$ List a $\to$ Stream$^\kappa$ a $\to$ Stream$^\kappa$ a
  prepend = $\Lambda\kappa.\,$fix$^\kappa$($\lambda$rec.$\lambda$a.$\lambda$xs.$\lambda$s.$\,$prepend$'\;$rec a xs s)
\end{lstlisting}
As \texttt{prepend} is now defined with a fixed point, the recursive reference
\texttt{rec} is inserted in place of the original recursive reference. The
remainder of the right-hand sides from the original definition have been partially preserved
in \texttt{prepend$'$}, but have been underlined to indicate that they are no
longer well-typed according to the type specification.

(2) The type parameter \texttt{a} is lifted out of the fixed-point to make up
for the lack of type substitution in the later composition rule, as explained in
Section~\ref{sec:handling-parameters}. Note that this also lifts \texttt{a} out
of the type of the recursive reference, \texttt{rec}. Furthermore, \texttt{a} is
no longer bound under the clock quantification in the type of \texttt{prepend}.
\begin{lstlisting}[mathescape]
  prepend$'$ : (a$\,$:$\,$Type) $\to$ $\laterkappa$(List a $\to$ Stream$^\kappa$ a $\to$ Stream$^\kappa$ a) $\to$ 
             List a $\to$ Stream$^\kappa$ a $\to$ Stream$^\kappa$ a
  prepend$'$ a rec []        s = $\uwave{\texttt{s }}$
  prepend$'$ a rec (x :: xs) s = $\uwave{\texttt{x :: (rec xs s)}}$

  causal prepend : (a$\,$:$\,$Type) $\to$ ($\forall\kappa.\,$ List a $\to$ Stream$^\kappa$ a $\to$ Stream$^\kappa$ a)
  prepend a = $\Lambda\kappa.\,$fix$^\kappa$($\lambda$rec.$\lambda$xs.$\lambda$s.$\,$prepend$'$ a rec xs s)
\end{lstlisting}
(3) The fixed-point is eliminated by replacing all references to
\texttt{rec} with \texttt{Next~(prepend~a)~[$\kappa$]} in \texttt{prepend}, since this term has
exactly the same type as \texttt{rec} in step 2.
\begin{lstlisting}[mathescape]
  prepend$'$ : (a$\,$:$\,$Type) $\to$ $\laterkappa$(List a $\to$ Stream$^\kappa$ a $\to$ Stream$^\kappa$ a) $\to$ 
             List a $\to$ Stream$^\kappa$ a $\to$ Stream$^\kappa$ a
  prepend$'$ a rec []        s = $\uwave{\texttt{s }}$
  prepend$'$ a rec (x :: xs) s = $\uwave{\texttt{x :: (rec xs s)}}$

  causal prepend : (a$\,$:$\,$Type) $\to$ ($\forall\kappa.\,$ List a $\to$ Stream$^\kappa$ a $\to$ Stream$^\kappa$ a)
  prepend a = $\Lambda\kappa.\,$$\lambda$xs.$\lambda$s.$\,$prepend$'$ a (Next (prepend a)[$\kappa$]) xs s
\end{lstlisting}
(4) The \texttt{rec} argument to \texttt{prepend'} is eliminated by
$\beta$-reduction.
\begin{lstlisting}[mathescape]
  prepend$'$ : (a$\,$:$\,$Type) $\to$ List a $\to$ Stream$^\kappa$ a $\to$ Stream$^\kappa$ a
  prepend$'$ a []        s = $\uwave{\texttt{s }}$
  prepend$'$ a (x :: xs) s = $\uwave{\texttt{x :: ((Next (prepend a)}[\kappa]\texttt{) xs s)}}$

  causal prepend : (a$\,$:$\,$Type) $\to$ ($\forall\kappa.\,$ List a $\to$ Stream$^\kappa$ a $\to$ Stream$^\kappa$ a)
  prepend a = $\Lambda\kappa.\,$$\lambda$xs.$\lambda$s.$\,$prepend$'$ a xs s
\end{lstlisting}
After preprocessing, the inference system will attempt to build well-typed
guarded recursive right-hand sides for the underlined right-hand sides above.

\subsubsection{Preprocessing Non-causal Functions}
Non-causal definitions are preprocessed slightly differently, mainly because the
recursive reference has a different form on account of the use of the indexed
fixed-point introduced in Section~\ref{sec:guarded-recursion}. Consider the
following non-causal program, \texttt{evens}:
\begin{lstlisting}[mathescape]
evens : Stream a $\to$ Stream a
evens s = head s :: evens (tail (tail s))
\end{lstlisting}
(1) Initially, two auxiliary functions are created, \texttt{evens$'$} and
\texttt{evens$''$}. The \texttt{evens$'$} function is necessary because its type
enables us to use the indexed fixed-point, \texttt{pfix$^\kappa$}, to provide a recursive reference
without clock quantification in its result type.
\begin{lstlisting}[mathescape]
evens$''$ : ($\forall\kappa.\,$(a$\,$:$\,$Type) $\to$ $\forall\kappa.\,$Stream$^\kappa$ a $\to$ $\laterkappa$Stream$^\kappa$ a) $\to$ 
          $\forall\kappa.\,$(a$\,$:$\,$Type) $\to$ $\forall\kappa.\,$Stream$^\kappa$ a $\to$ Stream$^\kappa$ a
evens$''$ rec a s = $\uwave{\texttt{head s :: rec a (tail (tail s))}}$

evens$'$ : $\forall\kappa.\,$(a$\,$:$\,$Type) $\to$ $\forall\kappa.\,$Stream$^\kappa$ a $\to$ Stream$^\kappa$ a
evens$'$ = pfix$^\kappa$($\lambda$rec.$\lambda$a.$\lambda$s. evens$''$ rec s)

evens : $\forall\kappa.\,$(a$\,$:$\,$Type) $\to$ $\forall\kappa.\,$Stream$^\kappa$ a $\to$ $\forall\kappa.\,$Stream$^\kappa$ a
evens = $\Lambda\kappa.\,$evens$'$
\end{lstlisting}
(2) Exactly as for the causal case, the type parameter is lifted out of the fixed-point.
\begin{lstlisting}[mathescape]
evens$''$ : $\forall\kappa.\,$(a$\,$:$\,$Type) $\to$ ($\forall\kappa.\,$Stream$^\kappa$ a $\to$ $\laterkappa$Stream$^\kappa$ a) $\to$ 
         $\forall\kappa.\,$Stream$^\kappa$ a $\to$ Stream$^\kappa$ a
evens$''$ a rec s = $\uwave{\texttt{head s :: rec (tail (tail s))}}$

evens$'$ : $\forall\kappa.\,$(a$\,$:$\,$Type) $\to$ $\forall\kappa.\,$Stream$^\kappa$ a $\to$ Stream$^\kappa$ a
evens$'$ a = pfix$^\kappa$($\lambda$rec.$\lambda$s. evens$''$ a rec s)

evens : $\forall\kappa.\,$(a$\,$:$\,$Type) $\to$ $\forall\kappa.\,$Stream$^\kappa$ a $\to$ $\forall\kappa.\,$Stream$^\kappa$ a
evens a = $\Lambda\kappa.\,$evens$'$ a
\end{lstlisting}
(3.1) The indexed fixed-point is replaced by the equivalent ordinary guarded
recursive fixed-point. This step requires that the recursive reference is
placed inside a function which lifts its argument into a $\laterkappa$ context.
\begin{lstlisting}[mathescape]
evens$''$ : $\forall\kappa.\,$(a$\,$:$\,$Type) $\to$ ($\forall\kappa.\,$Stream$^\kappa$ a $\to$ $\laterkappa$Stream$^\kappa$ a) $\to$ 
         $\forall\kappa.\,$Stream$^\kappa$ a $\to$ Stream$^\kappa$ a
evens$''$ a rec s = $\uwave{\texttt{head s :: rec (tail (tail s))}}$

evens$'$ : $\forall\kappa.\,$(a$\,$:$\,$Type) $\to$ $\forall\kappa.\,$Stream$^\kappa$ a $\to$ Stream$^\kappa$ a
evens$'$ a = fix$^\kappa$($\lambda$rec.$\lambda$s. evens$''$ a ($\lambda$x.$\,$rec $\tensor^\kappa$ (Next x)) s)

evens : $\forall\kappa.\,$(a$\,$:$\,$Type) $\to$ $\forall\kappa.\,$Stream$^\kappa$ a $\to$ $\forall\kappa.\,$Stream$^\kappa$ a
evens a = $\Lambda\kappa.\,$evens$'$ a
\end{lstlisting}
(3.2) The fixed-point is eliminated according to the rules in Figure~\ref{fig:fix_elim_rules}.
\begin{lstlisting}[mathescape]
evens$''$ : $\forall\kappa.\,$(a$\,$:$\,$Type) $\to$ ($\forall\kappa.\,$Stream$^\kappa$ a $\to$ $\laterkappa$Stream$^\kappa$ a) $\to$ 
         $\forall\kappa.\,$Stream$^\kappa$ a $\to$ Stream$^\kappa$ a
evens$''$ a rec s = $\uwave{\texttt{head s :: rec (tail (tail s))}}$

evens$'$ : $\forall\kappa.\,$(a$\,$:$\,$Type) $\to$ $\forall\kappa.\,$Stream$^\kappa$ a $\to$ Stream$^\kappa$ a
evens$'$ a = $\lambda$s. evens$''$ a ($\lambda$x.$\,$Next (evens$'$ a) $\tensor^\kappa$ (Next x)) s

evens : $\forall\kappa.\,$(a$\,$:$\,$Type) $\to$ $\forall\kappa.\,$Stream$^\kappa$ a $\to$ $\forall\kappa.\,$Stream$^\kappa$ a
evens a = $\Lambda\kappa.\,$evens$'$ a
\end{lstlisting}
(4) The \texttt{rec} argument to \texttt{evens$''$} is eliminated by $\beta$-reduction.
\begin{lstlisting}[mathescape]
evens$''$ : $\forall\kappa.\,$(a$\,$:$\,$Type) $\to$ $\forall\kappa.\,$Stream$^\kappa$ a $\to$ Stream$^\kappa$ a
evens$''$ a s = $\uwave{\texttt{head s :: (}\lambda\texttt{x.}\,\texttt{Next (evens}'\texttt{ a) }\tensor^\kappa\texttt{ (Next x)) (tail (tail s))}}$

evens$'$ : $\forall\kappa.\,$(a$\,$:$\,$Type) $\to$ $\forall\kappa.\,$Stream$^\kappa$ a $\to$ Stream$^\kappa$ a
evens$'$ a = $\lambda$s. evens$''$ a s

evens : $\forall\kappa.\,$(a$\,$:$\,$Type) $\to$ $\forall\kappa.\,$Stream$^\kappa$ a $\to$ $\forall\kappa.\,$Stream$^\kappa$ a
evens a = $\Lambda\kappa.\,$evens$'$ a
\end{lstlisting}
The inference system can now attempt to infer a guarded recursive version of the
underlined right-hand sides.

For neither the causal or the non-causal case, all the steps presented above are
actually performed. Instead, we provide the setup for the inference system by
proceeding directly to the last step.

\subsection{The Inference System}
\label{sec:inference-system}
% RULES
% Regler - forklar (også notation)
% Rekursive referencer
% Eksempel - zeros?
% Preprocessing
% Renaming
% Forskel på causal og non causal

%(1) Gennemgang af interessante regler
%(2) Eksempel
%(3) Implementation details, e.g. when Next and tensor rules clash
%%(3.1) Preprocessing, herunder renaming
%%(3.2) Forskel på causal og non causal

Inference of guarded recursive TT terms from elaborated TT terms happens by a
bottom-up, type-directed derivation according to the rules given in
Figure~\ref{fig:epsilon_rules}\todo{Behøver vi tjekke :Type præmisserne
  her?}. Let $\Gamma$ be a typing environment and $\iota$ be the recursive
reference for the function which is currently being analysed. Then the inference
environment ($IE$) in which guarded recursive TT terms are built is defined as follows:
\begin{align*}
   c,\,c^\prime &::=\,\open\,|\,\closed & \text{(singleton clock)} \\
   \Psi &::=\,\causal\,|\,\noncausal & \text{(modality)} \\
   \rho &::= (n,\, _gn)\,|\,(n,\, _gn,\, _{\forall}n) & \text{(renaming)} \\
   \phi &::=\,\cdot\,|\,\rho\,\phi & \text{(collection of renamings)} \\
   IE &::= \iota;\Psi;\phi;\,c;\,\Gamma & \text{(inference environment)}
\end{align*}
The singleton clock is either open (\open) or closed (\closed). Tuples given as $\rho$ match an Idris name $n$ to a
guarded name $_gn$. For record projections, a name for its forall-projection,
$_{\forall}n$, is also specified in $\rho$. Modality is specified by $\Psi$, and
is either causal (\causal) or non-causal (\noncausal). Inference (\infer) of a guarded recursive TT
term $e'$ of type $B$ from an elaborated TT term $e$ of type $A$ is then defined as
${IE\vdash e : A \Longrightarrow e^\prime : B}$.

% In Figure~\ref{fig:epsilon_rules}, the $\Longrightarrow_{Next^\kappa}$ rule follows directly from the $Next$ rule in Figure~\ref{fig:guarded_recursion_rules_clocks}. The
% $\Longrightarrow_{\Lambda\kappa}$ and $\Longrightarrow_{apply^\kappa}$ rules have a
% similar structure, but here the clock changes state from premise to conclusion
% (e.g. from open to closed). For handling guarded names, the
% $\Longrightarrow_{\phi}$ rule says that if some Idris name has type $A$, and its
% guarded version has type $A^\prime$, then we can insert the guarded name in its
% place. Note that the type $A^\prime$ of the guarded name is not arbitrary, but follows the
% rules for causal and non-causal function types (see Section~\todo{insert ref
%   here}). Renaming is important for the $\Longrightarrow_{App}$ rule, since it
% is often used for the transformations required in the premises. This reasoning
% also applies to the $\Longrightarrow_{\tensor^{\kappa}_{n}}$ rule. Here,
% the $n$ is a natural number denoting the required ``lateness'' of both input and
% output, where $n \ge 1$. Specifically, ${\laterkappa_{\!\!1} B \cong \laterkappa B}, {\laterkappa_{\!\!2}
% \cong \laterkappa\laterkappa B}$ and so on. For trivial cases, the
% $\Longrightarrow_{Refl}$ rule is used. \todo{Say something about abstraction and
% let-rules here, when they have been formulated.}

\begin{figure}
\centering
\textbf{The Inference System}$\hfill \boxed{IE\vdash e : A \infer e' : B}$
\vspace{1em}
\subcaptionbox{
The rule for inferring \texttt{Next} applications.
}{\input{figures/epsilon_next_rule}}
\vspace{1em}
\subcaptionbox{
The $\infer_{\Lambda\kappa}$-rule opens the closed clock. Due to the use of
a singleton clock, it is impossible to open a new clock in a context where the
clock is already open.
}{\input{figures/epsilon_lambdakappa_rule}}
\vspace{1em}
\subcaptionbox{
The $\infer_{[\kappa]}$-rule is dual to the  $\infer_{\Lambda\kappa}$-rule,
closing the open clock by clock application.
}{\input{figures/epsilon_apply_rule}}
\vspace{1em}
\subcaptionbox{
This rule replaces one reference to a name with another. In particular, if the
renaming context, $\phi$, contains an entry for the name referred to by $e$,
then $_{g}e$ can be substituted for $e$.
}{\input{figures/epsilon_renaming_rule}}
\vspace{1em}
\subcaptionbox{
Similar to the $\infer_{\phi}$-rule, this rules disambiguates between the
guarded renaming and the forall-renaming for a term, when both are available.
}{\input{figures/epsilon_renaming_rule_forall}}
\vspace{1em}
\subcaptionbox{
This rule ensures that the system is invoked recursively on the subterms
of an application which is not expected to be in a $\laterkappa$ context.
}{\input{figures/epsilon_app_rule}}
\vspace{1em}
\subcaptionbox{
The $\infer_{\tensor^\kappa_n}$ rule is used when the guarded recursive version
of an application is expected to be in a $\laterkappa$ context. Here, $n$ is a natural number denoting the
required availability of both input. Specifically, ${\laterkappa_{\!\!1} B \cong \laterkappa B}, {\laterkappa_{\!\!2}
\cong \laterkappa\laterkappa B}$ and so on. Note that as discussed in
Section~\ref{sec:fixkappa-rule}, this rule does not apply to dependent function spaces.
}{\input{figures/epsilon_tensor_rule}}
\vspace{2em}
\end{figure}

\begin{figure}
\centering
\ContinuedFloat
\subcaptionbox{
The reflexivity rule simply states that any term can be inferred to itself. This
rule is used for terms which occur in both the elaborated TT term and the guarded
recursive TT term, e.g. constants.
}{\input{figures/epsilon_refl_rule}}

\vspace{1em}
\subcaptionbox{
  The $\infer_\lambda$-rule handles the recursive case by adding a new renaming
  entry to the renaming environment, $\phi$, such that all occurrences of the
  bound variable $a$ in $e$ can be renamed to $_{g}a$.
}{\input{figures/epsilon_lambda_rule}}

\vspace{1em}
\subcaptionbox{
As for the $\infer_\lambda$-rule, the $\infer_{let}$-rule uses the renaming
environment for the recursive case for $b$.  
}{\input{figures/epsilon_let_rule}}
  \caption{Rules for inferring guarded recursive terms, excluding the rules for
    recursive references. All types used in typing judgments are assumed to be well-formed.}
  \label{fig:epsilon_rules}
\end{figure}

\begin{figure}
\centering
\subcaptionbox{
Due to the elimination of the indexed fixed-point, this rule ensures that no
arguments to the non-causal recursive reference has a type in a $\laterkappa$
context. The $e\, \overset{\rightarrow}{x_n}$ notation denotes the recursive reference,
$e$, applied to arguments $x_0,\,x_1\,\cdots\,x_n$.
}{\input{figures/epsilon_rec_noncausal_n}}

\vspace{1em}
\subcaptionbox{
Handles the non-causal recursive reference applied to one argument. This rule
is necessary since the recursive case for $e$ is different from the $\infer_{Rec_{\noncausal{_n}}}$-rule.
}{\input{figures/epsilon_rec_noncausal_1}}

\vspace{1em}
\subcaptionbox{
This rule ensures that a \texttt{Next} is always applied to any non-causal recursive reference.
}{\input{figures/epsilon_rec_noncausal}}
  \caption{Rules for non-causal recursive references. All types used in typing judgments are assumed to be well-formed.}
\end{figure}

\begin{figure}
  \centering
\input{figures/epsilon_rec_causal}
  \caption{The rule for recursive references for causal functions. All types used in typing judgments are assumed to be well-formed.}
\end{figure}

\paragraph{An Example}

Figure~\ref{fig:epsilon_zeros} shows how a guarded recursive version of
\texttt{zeros} can be inferred using the rules presented in Figure~\ref{fig:epsilon_rules}. The
derivation proceeds by continually pushing type requirements down into the
syntax tree, until these can be resolved either trivially (using the
$\Longrightarrow_{Refl}$ rule), or by renaming (using the
$\Longrightarrow_{\phi}$ rule). Note that all premises ensuring type consistency
have been omitted for brevity. A full example, along with a more advanced one,
can be found in Appendix~\ref{app:infer-guard-recurs}.\todo{Make this appendix}
\begin{figure}
\begin{lstlisting}[mathescape]
causal zeros : Stream Nat
zeros = Z :: zeros

$_g$zeros : $\forall\kappa.$ $_g$Stream Nat
$_g$zeros = $\Lambda\kappa.$ Z $_g$:: (Next (apply $_g$zeros))
\end{lstlisting}
  % \[
  % \frac{x}{\eps{IE}{Z :: zeros}{Stream Nat}{IE}{Z :: gzeros}{gStream Nat}}
  % \]
%\input{figures/epsilon_zeros}
  \caption{Above: The user-provided program \texttt{zeros}, along with the
    inferred program $_g$\texttt{zeros}. Below: Inferring $_g$\texttt{zeros} from \texttt{zeros} using the rules from
  Figure~\ref{fig:epsilon_rules}.}
  \label{fig:epsilon_zeros}
\end{figure}

\subsubsection{Implementing the Inference System}

\paragraph{Preprocessing} Two aspects of the inference system, renaming and
delaying the recursive reference, are mandatory, and these 
are therefore handled in a separate preprocessing step. Both must take modality
into account.

Renaming, i.e. all applications of the $\Longrightarrow_{\phi}$ rule, is
performed by substituting all Idris names in $\phi$ with their guarded
versions. Special care must be taken when substituting names of projection
functions, since the modality of the function in question, $f$, influences the choice
of guarded name. If $f$ is causal, 

Delaying the recursive reference
%Preprocessing
%Modality and Recursive reference
%When rules clash


\subsection{The Guarded Recursion Checker}
% How are side conditions handled?
% How are recursive references?
To check that what we infer actually conforms to the guarded recursion rules, we
have implemented a checker. This algorithm simply checks a term to have a given
type within the rule from Figure~\ref{fig:gr_rules_sin_clock}. To the algorithm
less error prone it is implemented in the simplest fashion possible and as
attempts to stick strictly to the typing rules. This means that the checking
algorithm is very simple, conservative, and rigid. It expect types and terms to
be of a specific structure, and it discards anything it can guarantee the
correctness off. 

The checker traverses a term, and unfolds them according to the rules. Any rules
that requires a type equality is done by asking the Idris type system for
conversion equality, and if the type of a term is needed it is checked using the
Idris type checker.

The structure of the code itself aims to take care of as much as the check using
pattern matching. While not always possible, ideally the conclusion of a rule
should be represented by a pattern match, and the premise(s) by a right-hand
side. By doing this we can, through different patterns, be very selective about
what is accepted by the checker and discard anything that does not match the
conclusion of a rule.

Getting more into the actual implementation the checking algorithm is a function
\texttt{check}, with the type signature seen in Figure~\ref{fig:check_type}. The
parameters are as follows:\todo{Is this too low level?}

\begin{itemize}
\item \texttt{Clock} is the clock under which we are checking the term. A clock
  is simply either open or closed.
\item \texttt{Env} is the local environment, usually generated from the
  left-hand side of the clause being checked.
\item \texttt{(Name, Type)} is name and the type of the recursive
  reference. 
\item \texttt{Term} is the term being checked.
\item \texttt{Type} is the type the term is being checked to have.
\item \texttt{Idris Totality} is the result of the algorithm wrapped in the
  Idris monad\todo{Is the Idris monad explained at this point?}. 
\end{itemize}

\begin{figure}[h]
\begin{lstlisting}
check :: Clock -> 
         Env -> 
         (Name, Type) -> 
         Term -> 
         Type -> 
         Idris Totality
\end{lstlisting}  
  \caption{Checking algorithm type.}
  \label{fig:check_type}
\end{figure}

The majority of the conclusions of the rules can be reflected as patterns. If we
wish to e.g. delay a term, the $Next_i$-rule requires that, (1) the clock is
open, (2) the term is on the form $Next t$, and (3) the type is on the form
$\later A$. These requirements are expressed as a pattern in
Figure~\ref{fig:next_pattern}. The view-patterns can be read as regular pattern
match, such that \texttt{next -> Extracted t} is \texttt{Next t}. The premise
from the rule is reflected on the right-hand side. simply check that given the
same environments \texttt{t} has type \texttt{a}.

\begin{figure}[h]
\begin{lstlisting}
check Open g n (next -> Extracted t) (later -> Extracted a) 
     =
     check Open g n t a
\end{lstlisting}
  \caption{$Next_{i}$ pattern. Note the use of view-patterns (the -> syntax).}
  \label{fig:next_pattern}
\end{figure}

\paragraph{No Free Clocks in Environment}
% No free clocks in finished definitions.
% Check everything in local environment with closed clock.
Some rules have a side condition dictating that there must no free clocks in the
variable environment. These are checked by checking that every term in the
variable can be checked under a closed clock. This is the same as no clocks
being free, because any term or type with a free clock would require the clock
to be open in order to be well-formed. 
\paragraph{Identifying the Recursive Reference}
\todo{This paragraph needs more implementation to be written}
%##########
% To faser: Inferens og check - bør kunne beskrives separat
% Inferens - regler
% Check - regler
% Correctness claim - Hvordan kan vi være sikre på at vi inferer guarded
% recursion?
% Preservation of semantics - Har den infererede term samme semantik som
% input-termen?
% Tensor-regel og parametre
%##########


\section{Discussion}
Although the system presented throughout this chapter can prove productive quite
a few realistic programs (see Chapter~\ref{cha:evaluation}), it currently has
several shortcomings and limitations
%\subsection{Guarded Recursion and Dependent Types}

\subsection{Preservation of Semantics}
In Section~\ref{sec:inference-system}, we presented the rules for inferring
guarded recursive TT terms from elaborated TT terms. Even though we are
confident in our approach, we have no proof that the semantics of the inferred
guarded recursive terms are the same as the semantics of the input
terms. Naturally, the guarded recursive version must have the same semantics in
order for the productivity analysis to have any value. We imagine that such a
proof could be provided by showing that the input term and the output term of each
rule reduce to the same or equivalent TT semantics. The TT
semantics are defined by Brady\,\citep{BradyIdrisImpl13}.

\subsection{Type Class Instances}

\subsection{Mutual Recursion}
Since our productivity analysis emerges from the use of the guarded recursive
fixed-point defined in Section~\ref{sec:guarded-recursion}, mutually recursive
definitions are not (yet) supported. The reason is that our analysis prevents
infinite recursion by ensuring that all direct recursive references are not
immediately available, seeing as they must have a type under a specific type
constructor, later ($\laterkappa$). If other constructs can lead to infinite
recursion, these must be identified separately. This is deferred as future work
(see Chapter~\ref{cha:future-work}).

\subsection{Totality Dependencies}
Currently, the system does not keep track of totality dependencies between
functions. Consider the following program:
\begin{lstlisting}[mathescape]
nats : Stream Nat
nats = Z :: map S nats
\end{lstlisting}
Here, \texttt{nats} depends on the totality of \texttt{map}. If \texttt{map}
turns out to be partial, it is not currently detected that \texttt{nats} is also
partial as a consequence thereof. The reason is that the productivity analysis
of \texttt{nats} relies on the promise that a total version of \texttt{map} will
or has been found, and not on the actual implementation of \texttt{map}.

\subsection{User-provided Guarded Recursion}
% Problem: Non-causal functions require two functions
%% However, the checker checks non-causal definitions in an open clock

\subsection{Multiple Clocks}


\subsection{Error Reporting}
Giving helpful error messages concerning guarded recursion can be difficult,
mainly because it may require that the user is familiar or at least partially
familiar with the underlying theory. Aside from that, it should be possible to
generate quite detailed error messages, considering that each rule may fail
independently. We have not yet put any effort into providing helpful error
messages, but we imagine that such messages could have the form: ``The causal
definition $f$ is not productive because $x$ at line $n$, column $c$, has no
guarded recursive form of type $A'$ (inferred from type $A$)''. All information
used in this example is directly available in each of the inference rules.






%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../copatterns-thesis"
%%% End:
